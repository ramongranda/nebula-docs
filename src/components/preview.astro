---
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'div'> {
	labels?: {
		lightMode?: string;
		darkMode?: string;
		bodyText?: string;
		linkText?: string;
		dimText?: string;
		inlineCode?: string;
	};
	title?: string;
	icon?: string;
}
const { labels: incomingLabels, title: incomingTitle, icon: incomingIcon, ...attrs } = Astro.props as Props;
const light = 'data-light' in attrs;
const linkColor = light ? '--sl-color-accent' : '--sl-color-accent-high';
const codeBg = light ? '--sl-color-gray-6' : '--sl-color-gray-5';

const defaultLabels = {
	lightMode: 'Light preview',
	darkMode: 'Dark preview',
	bodyText: 'This is a preview.',
	linkText: 'A link',
	dimText: '',
	inlineCode: 'inline code',
};
if (!incomingLabels) {
	// eslint-disable-next-line no-console
	console.warn('preview component: missing `labels` prop â€” using defaults');
}
const labels = { ...defaultLabels, ...(incomingLabels ?? {}) };
const previewTitle = incomingTitle ?? null;
const previewIcon = incomingIcon ?? null;
---

<div
	class="preview-card"
	data-label-light={labels.lightMode}
	data-label-dark={labels.darkMode}
	data-body-text={labels.bodyText}
	data-link-text={labels.linkText}
	data-dim-text={labels.dimText}
	data-inline-code={labels.inlineCode}
	data-preview-title={previewTitle}
	data-preview-icon={previewIcon}
	{...attrs}
>
	<slot name="preview">
		<div class="preview-tabs">
			<div class="preview-tabs-header">
				<div class="preview-title">
					<span class="preview-icon" aria-hidden="true" data-icon={previewIcon ?? ''}></span>
					<strong class="preview-heading">{previewTitle ?? (light ? labels.lightMode : labels.darkMode)}</strong>
				</div>
				<div class="preview-tabs-buttons" role="tablist" aria-label="Preview tabs">
					<button type="button" data-tab="preview" class="tab-btn">Preview</button>
					<button type="button" data-tab="markdoc" class="tab-btn">Markdoc</button>
					<button type="button" data-tab="source" class="tab-btn">Source</button>
				</div>
			</div>

			<div class="preview-tabs-body">
				<div class="tab-content" data-tab="preview">
					<slot name="preview">
						<h4>{light ? labels.lightMode : labels.darkMode}</h4>
						<p>
							{labels.bodyText}{' '}
							<span class="link" style={`color:var(${linkColor})`}>{labels.linkText}</span>{' '}
							<span class="dim">{labels.dimText}</span>{' '}
							<code style={`--sl-color-bg-inline-code:var(${codeBg})`}>{labels.inlineCode}</code>
						</p>
					</slot>
				</div>

				<div class="tab-content" data-tab="markdoc">
					<slot name="markdoc"><!-- empty markdoc fallback --></slot>
				</div>

				<div class="tab-content" data-tab="source">
					<slot><!-- default slot: source code block --></slot>
				</div>
			</div>
		</div>
	</slot>
</div>

<script type="module">
// Client-side: detect actual UI theme and update preview labels live
const root = document.querySelector('.preview-card');
if (root) {
	function detectIsLight() {
		const de = document.documentElement;
		const themeAttr = de.getAttribute('data-theme') ?? de.dataset.theme;
		if (themeAttr) return themeAttr === 'light';
		if (de.classList.contains('dark') || de.classList.contains('sl-theme-dark')) return false;
		try {
			const ls = localStorage.getItem('theme');
			if (ls) return ls === 'light';
		} catch (e) {}
		if (window.matchMedia) return window.matchMedia('(prefers-color-scheme: light)').matches;
		return true;
	}

	function applyLabels(isLight) {
		const lbl = isLight ? root.dataset.labelLight : root.dataset.labelDark;
		const body = root.dataset.bodyText ?? '';
		const link = root.dataset.linkText ?? '';
		const dim = root.dataset.dimText ?? '';
		const inline = root.dataset.inlineCode ?? '';

		const h4 = root.querySelector('h4');
		const p = root.querySelector('p');
		const linkEl = root.querySelector('.link');
		const dimEl = root.querySelector('.dim');
		const codeEl = root.querySelector('code');

		if (h4) h4.textContent = lbl;
		if (p) {
			const firstText = Array.from(p.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
			if (firstText) firstText.textContent = body + ' ';
			else p.prepend(document.createTextNode(body + ' '));
		}
		if (linkEl) linkEl.textContent = link;
		if (dimEl) dimEl.textContent = dim;
		if (codeEl) codeEl.textContent = inline;
	}

	applyLabels(detectIsLight());

	// Tabs: hide buttons for empty tabs and wire up tab switching.
	const tabsHeader = root.querySelector('.preview-tabs-buttons');
	const tabButtons = Array.from(root.querySelectorAll('.tab-btn'));
	const tabContents = Array.from(root.querySelectorAll('.tab-content'));

	function hasContentFor(tabName) {
		const el = root.querySelector(`.tab-content[data-tab="${tabName}"]`);
		return el && el.childNodes && Array.from(el.childNodes).some(n => {
			// ignore empty text nodes and comment nodes
			return !(n.nodeType === Node.TEXT_NODE && n.textContent.trim() === '') && n.nodeType !== Node.COMMENT_NODE;
		});
	}

	// Remove/hide buttons for tabs that have no content
	tabButtons.forEach(btn => {
		const name = btn.getAttribute('data-tab');
		if (!hasContentFor(name)) btn.style.display = 'none';
	});

	// Choose initial active tab: prefer preview, then markdoc, then source
	const preferred = ['preview', 'markdoc', 'source'];
	let active = preferred.find(hasContentFor) || 'preview';

	function setActive(tabName) {
		tabButtons.forEach(b => b.classList.toggle('active', b.getAttribute('data-tab') === tabName));
		tabContents.forEach(c => c.style.display = c.getAttribute('data-tab') === tabName ? '' : 'none');
		// when switching to source, try to parse meta from the code block to set title/icon
		if (tabName === 'source') parseAndApplyMeta();
	}

	tabButtons.forEach(b => b.addEventListener('click', () => setActive(b.getAttribute('data-tab'))));
	setActive(active);

	// Try to parse attributes (title/icon) from the source tab's first <pre> or <code>
	function parseAndApplyMeta() {
		// If server provided explicit preview props, prefer them and don't override
		const serverTitle = root.dataset.previewTitle;
		const serverIcon = root.dataset.previewIcon;
		if (serverTitle || serverIcon) return;
		const sourceEl = root.querySelector('.tab-content[data-tab="source"]');
		if (!sourceEl) return;
		const codeEl = sourceEl.querySelector('pre') || sourceEl.querySelector('code');
		let metaText = '';
		if (codeEl) {
			// check data-meta attributes
			metaText = codeEl.getAttribute('data-meta') || codeEl.dataset.meta || '';
			// fallback: inspect className for patterns like title="..." or icon="..."
			if (!metaText && codeEl.className) metaText = codeEl.className;
			// fallback: inspect first line of code text for a meta comment like <!-- meta: title="..." -->
			if (!metaText && codeEl.textContent) {
				const firstLine = codeEl.textContent.split('\n', 1)[0];
				const match = firstLine.match(/title=\"([^\"]+)\"|icon=\"([^\"]+)\"/);
				if (match) metaText = match[0];
			}
		}

		const meta = {};
		if (metaText) {
			// crude parser for key="value" pairs
			const re = /([a-zA-Z0-9_-]+)\s*=\s*\"([^\"]+)\"/g;
			let m;
			while ((m = re.exec(metaText))) meta[m[1]] = m[2];
		}

		const heading = root.querySelector('.preview-heading');
		const icon = root.querySelector('.preview-icon');
		if (meta.title && heading) heading.textContent = meta.title;
		if (meta.icon && icon) {
			// try to set an inline icon class (consumers can style .preview-icon[data-icon="name"]) 
			icon.setAttribute('data-icon', meta.icon);
			icon.textContent = '';
		}
	}

	// Observe theme changes (class/attribute changes on <html>) and update live.
	const obs = new MutationObserver(() => {
		applyLabels(detectIsLight());
	});
	obs.observe(document.documentElement, { attributes: true, attributeFilter: ['class', 'data-theme'] });
}
</script>

<style>
	.preview-card {
		margin: 0 !important;
		border: 1px solid var(--sl-color-hairline);
		padding: 1rem;
		background-color: var(--sl-color-bg);
	}

	.preview-tabs-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem}
	.preview-tabs-buttons{display:flex;gap:0.25rem}
	.tab-btn{background:transparent;border:1px solid transparent;padding:0.25rem 0.5rem;border-radius:4px;cursor:pointer}
	.tab-btn.active{border-color:var(--sl-color-hairline);background:var(--sl-color-bg-sidebar)}
	.tab-content{display:none}

	p {
		margin-top: 0.5em !important;
		font-size: var(--sl-text-sm);
		color: var(--sl-color-text);
	}

	.link {
		text-decoration: underline;
	}

	.dim {
		color: var(--sl-color-gray-3);
	}
</style>
